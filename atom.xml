<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>timlyeee.github.io</title>
  
  <subtitle>Live with BUG</subtitle>
  <link href="http://timlyeee.github.io/atom.xml" rel="self"/>
  
  <link href="http://timlyeee.github.io/"/>
  <updated>2023-01-05T12:56:11.062Z</updated>
  <id>http://timlyeee.github.io/</id>
  
  <author>
    <name>timlyeee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>integrateCocosToHexo</title>
    <link href="http://timlyeee.github.io/2022/05/11/integrateCocosToHexo/"/>
    <id>http://timlyeee.github.io/2022/05/11/integrateCocosToHexo/</id>
    <published>2022-05-11T10:42:28.000Z</published>
    <updated>2023-01-05T12:56:11.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>对于cocos：</p><ul><li>运行在github.io上，静态页面加载，不占资源。</li></ul><p>对于hexo：</p><ul><li>hexo s时可以显示场景，以及资源能够正确加载。</li><li>快速的部署一个新的场景或者小游戏</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;对于cocos：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行在github.io上，静态页面加载，不占资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于hexo：</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我只想 定制个人专属的 Hexo 主题</title>
    <link href="http://timlyeee.github.io/2022/05/04/hackUrTheme/"/>
    <id>http://timlyeee.github.io/2022/05/04/hackUrTheme/</id>
    <published>2022-05-04T08:42:50.000Z</published>
    <updated>2023-01-05T12:56:11.062Z</updated>
    
    <content type="html"><![CDATA[<p>“这我实在受不了，太枯燥了。”我盯着电脑发呆。这是我将近一个月以来第一次在晚上还需要写代码或者查bug。我心想，如果有这时间我倒不如写一些博客了。可是上一次博客在哪里写的？写到哪里了？真他娘的是个好问题。</p><p>“Hexo的迁移指南？”看着上一次迁移时的记录日志我不禁有些发愣。“整体拷贝项目到另一个文件夹？有些可取之处，但也仅限于能够保留完整的node_module的库文件，不会因为node环境变化而发生不测了吧。”我叹了口气。上一次的博客应该是在家里写的吧，用的windows环境。要是再换一次，可得累死。</p><p>“还是换成github托管吧，重新下一遍依赖也无所谓了。”我点开github创建了私人仓库，从而能够把个人的老旧项目push上去。“hexo也要升级。不然新版本怕是会有破坏兼容性的问题。。。？艹？怎么报错了？”我揉了揉眼睛，不对啊，这玩意儿我也没改版本啊？</p><p>“主题只支持到hexo3.x版本？？主题还有版本限制的？那岂不是新的插件都用不了？”我叹了口气，最近的生活充斥着妥协，现在就连博客都开始需要我妥协了吗？“算了换个主题吧。”</p><p>我点开Hexo的主题界面，眼花缭乱的主题们映入我的眼帘，这一刻我是幸福的，看，这么多主题可以给我翻牌子。但风格化的东西却很少。</p><p>对于个人博客我尤其不满的一点就是博客的风格主题，虽然hexo的主题商店里面有很多可以选择的主题，大多也具备适应性布局，简约和markdown语法解析等功能，但是主题的定制化一直是个问题。我尤其没有办法定制属于自己的颜色。所以如果想要实现不同的艺术效果，就必须去看源码了。这可太不公平了，因为每个主题所使用的框架都不相同，我已经看到了不下三种完全不同风格的架构，ejs&#x2F;swig&#x2F;pug。对于我这样只是稍稍写写博客的人而言很难做到精通每一种框架。</p><p>“爷妥协了那么多次了，在完全属于我的个人博客里还要妥协？我办不到。”我的眼神凌厉起来，这种事情我确实不能忍，如果只是拷贝一个和原本差不多的主题，我为何不直接用简书或者知乎？我点开Hexo的主题推荐，最符合我自定义想法的主题框架还是越稳定越好，那么就选这一个了。<a href="https://github.com/theme-next/hexo-theme-next">Next</a>。“这次的主页，我想用粉色和青色作为主题，然后在主页加上涂鸦元素。。”我打开procreate画了起来。</p><h2 id="主页的设计"><a href="#主页的设计" class="headerlink" title="主页的设计"></a>主页的设计</h2><h3 id="定制Header"><a href="#定制Header" class="headerlink" title="定制Header"></a>定制Header</h3><p>关于定制Header我有许多可以说道的地方，毕竟网页的头部可以说是网站的门面，一定要是属于自己的风格，最初的设计是双色粉刷风格。</p><p>涂鸦般的字体<a href="https://codepen.io/rickyeckhardt/pen/nPaBEx">https://codepen.io/rickyeckhardt/pen/nPaBEx</a></p><p><a href="https://www.lionad.art/articles/css-light-travel.html">https://www.lionad.art/articles/css-light-travel.html</a></p><p>颗粒效果 <a href="https://css-tricks.com/grainy-gradients/">https://css-tricks.com/grainy-gradients/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“这我实在受不了，太枯燥了。”我盯着电脑发呆。这是我将近一个月以来第一次在晚上还需要写代码或者查bug。我心想，如果有这时间我倒不如写一些博客了。可是上一次博客在哪里写的？写到哪里了？真他娘的是个好问题。&lt;/p&gt;
&lt;p&gt;“Hexo的迁移指南？”看着上一次迁移时的记录日志我不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MacOSX上的OpenAL开源代码分析</title>
    <link href="http://timlyeee.github.io/2022/04/24/openal-research-for-recent-macosx/"/>
    <id>http://timlyeee.github.io/2022/04/24/openal-research-for-recent-macosx/</id>
    <published>2022-04-24T05:53:05.000Z</published>
    <updated>2023-01-05T12:56:11.065Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作上对于音频有一些issue需要处理，但是OpenAL的文档相当模糊，也鲜有StackOverflow的回答，无奈之下我决定依据Apple最新的<a href="https://opensource.apple.com/tarballs/OpenAL/">OpenAL开源代码</a>做一些调查分析。</p><p>最主要的关注点就是<code>alSourcePlay</code>接口的源码分析和状态分析。</p><h2 id="OpenAL-简单概念介绍"><a href="#OpenAL-简单概念介绍" class="headerlink" title="OpenAL 简单概念介绍"></a>OpenAL 简单概念介绍</h2><p>我们先抛开一切冗杂的前奏，直接从接口介绍几个必须了解的参数，以及为什么我们要关注它们。</p><h3 id="AL-SOURCE-STATE-音频播放状态"><a href="#AL-SOURCE-STATE-音频播放状态" class="headerlink" title="AL_SOURCE_STATE 音频播放状态"></a>AL_SOURCE_STATE 音频播放状态</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Source state information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_SOURCE_STATE                           0x1010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_INITIAL                                0x1011</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_PLAYING                                0x1012</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_PAUSED                                 0x1013</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_STOPPED                                0x1014</span></span><br></pre></td></tr></table></figure><p>音频的状态被记录在<code>alSource</code>相关的结构体中，几百年没动过，这对应了音频的播放状态，在调用<code>alSourcePlay</code>之后就会进行相应的变化。当然，其他的播放控制函数也会同步调整它。如<code>alSourceStop</code>，<code>alSourcePause</code>等。</p><h3 id="alSource-音频ID"><a href="#alSource-音频ID" class="headerlink" title="alSource 音频ID"></a>alSource 音频ID</h3><p>音频会作为一个结构存储起来，并返回一个<code>alSourceID</code>作为它的索引，由于ID往往是唯一的，所以<code>alSourceID</code>也被简写为<code>alSource</code>或者<code>sid</code>。基本上所有的API接口都不会直接操作结构体，而是通过传输sid完成。</p><h3 id="ALContext-AL上下文"><a href="#ALContext-AL上下文" class="headerlink" title="ALContext AL上下文"></a>ALContext AL上下文</h3><p>OpenAL是模仿OpenGL风格写的库，所以音频的播放载体被称为<code>ALContext</code>，也就是上下文，用来表明音频播放的环境及变量。上下文则依赖一个Device，就是播放设备。</p><p><code>ALContext</code>可以由开发者自己创建，相关的接口都包含在alc.h的头文件中。不过alc的意思就是alcontext。</p><h3 id="ALDevice-AL播放设备"><a href="#ALDevice-AL播放设备" class="headerlink" title="ALDevice AL播放设备"></a>ALDevice AL播放设备</h3><p>也是一个标识符，目前不是关注的重点。</p><h2 id="alSourcePlay的源码分析"><a href="#alSourcePlay的源码分析" class="headerlink" title="alSourcePlay的源码分析"></a>alSourcePlay的源码分析</h2><p>对外的API中，<code>alSourcePlay</code>无返回值，如果有错误则会放在统一的alError中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OPENAL_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPENAL_DEPRECATED API_DEPRECATED(<span class="string">&quot;OpenAL is deprecated in favor of AVAudioEngine&quot;</span>, macos(10.4, 10.15), ios(2.0, 13.0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// OPENAL_DEPRECATED</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">AL_API <span class="type">void</span> AL_APIENTRY <span class="title">alSourcePlay</span><span class="params">( ALuint sid )</span> OPENAL_DEPRECATED</span>;</span><br></pre></td></tr></table></figure><h3 id="源码流程解析"><a href="#源码流程解析" class="headerlink" title="源码流程解析"></a>源码流程解析</h3><p>在新版本的OpenAL源码中，<code>alSourcePlay</code>的实现则被放到了<code>oalImp.cpp</code>中。下面是源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="function">AL_API ALvoid AL_APIENTRY <span class="title">alSourcePlay</span><span class="params">(ALuint sid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LOG_SOURCE_USAGE</span></span><br><span class="line"> <span class="built_in">DebugMessageN1</span>(<span class="string">&quot;alSourcePlay--&gt; source %ld&quot;</span>, (<span class="type">long</span> <span class="type">int</span>) sid);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> OALSource *oalSource = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  oalSource = <span class="built_in">ProtectSourceObjectInCurrentContext</span>(sid);</span><br><span class="line">  oalSource-&gt;<span class="built_in">Play</span>();     <span class="comment">// start playing the queue</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (OSStatus      result) &#123;</span><br><span class="line">  <span class="built_in">DebugMessageN1</span>(<span class="string">&quot;ERROR: alSourcePlay FAILED = %s\n&quot;</span>, <span class="built_in">alGetString</span>(result));</span><br><span class="line">  <span class="built_in">alSetError</span>(result);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (...) &#123; <span class="comment">// Catch-all handler, which is activated for any exception * https://en.cppreference.com/w/cpp/language/try_catch</span></span><br><span class="line">  <span class="built_in">DebugMessage</span>(<span class="string">&quot;ERROR: alSourcePlay FAILED&quot;</span>);</span><br><span class="line">  <span class="built_in">alSetError</span>(AL_INVALID_OPERATION);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">ReleaseSourceObject</span>(oalSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其实播放的流程其实分为两个部分：</p><ol><li>获取id对应的<code>OALSource</code>对象。</li><li>使用try-catch尝试播放<code>OALSource</code>，如果失败则设置<code>alError</code>。</li></ol><p>获取<code>OALSource</code>对象则需要检测<code>ALContext</code>的合法性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// globals</span></span><br><span class="line"><span class="type">uintptr_t</span> gCurrentContext = <span class="number">0</span>;                                    <span class="comment">// token for the current context</span></span><br><span class="line"><span class="function">OALSource* <span class="title">ProtectSourceObjectInCurrentContext</span><span class="params">(ALuint inSID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> OALContext *oalContext = <span class="literal">NULL</span>;</span><br><span class="line"> OALSource *oalSource = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  oalContext = <span class="built_in">ProtectContextObject</span>(gCurrentContext);</span><br><span class="line">  oalSource = oalContext-&gt;<span class="built_in">ProtectSource</span>(inSID);</span><br><span class="line">  <span class="keyword">if</span> (oalSource == <span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">throw</span> ((OSStatus) AL_INVALID_NAME);  <span class="comment">// per OpenAL 1.1 spec</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReleaseContextObject</span>(oalContext);</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">catch</span> (OSStatus stat) &#123;</span><br><span class="line">  <span class="built_in">ReleaseContextObject</span>(oalContext);</span><br><span class="line">  <span class="keyword">throw</span> stat;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">  <span class="built_in">ReleaseContextObject</span>(oalContext);</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> oalSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在oalImp中，<code>gCurrentContext</code>用uintptr代替本身的指针。这是为了兼容不同版本的API同时能够进行结构性调整。通过在这个<code>ALContext</code>中查找id所对应的<code>OALSource</code>，来获取到具体的对象。如果找不到，则抛出异常，并释放<code>ALContext</code>。这里的释放是通过将其InUseFlag清除。此处不深究。</p><p>顺利获取到音频之后，将调用其play函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OALSource::Play</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LOG_VERBOSE</span></span><br><span class="line"> <span class="built_in">DebugMessageN1</span>(<span class="string">&quot;OALSource::Play called - OALSource = %ld\n&quot;</span>, (<span class="type">long</span> <span class="type">int</span>) mSelfToken);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LOG_PLAYBACK</span></span><br><span class="line"> <span class="built_in">DebugMessageN2</span>(<span class="string">&quot;OALSource::Play called - OALSource:mState = %ld:%ld\n&quot;</span>, (<span class="type">long</span> <span class="type">int</span>) mSelfToken, mState);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// wait if in render, then prevent rendering til completion</span></span><br><span class="line">  <span class="function">OALRenderLocker::RenderLocker <span class="title">locked</span><span class="params">(mRenderLocker, InRenderThread())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// don&#x27;t allow synchronous source manipulation</span></span><br><span class="line">  <span class="function">CAGuard::Locker <span class="title">sourceLock</span><span class="params">(mSourceLock)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetQLengthPriv</span>() == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span>; <span class="comment">// nothing to do</span></span><br><span class="line">        </span><br><span class="line">  <span class="keyword">switch</span> (mState)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">case</span> AL_PLAYING:</span><br><span class="line">   <span class="keyword">case</span> kTransitionToPlay:</span><br><span class="line">   <span class="keyword">case</span> kTransitionToResume:</span><br><span class="line">   <span class="keyword">case</span> kTransitionToRetrigger:</span><br><span class="line">    <span class="keyword">if</span> (mRampState != kRampingComplete) </span><br><span class="line">    &#123;</span><br><span class="line">     mRampState = kRampDown;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LOG_MESSAGE_QUEUE     </span></span><br><span class="line">     <span class="built_in">DebugMessageN1</span>(<span class="string">&quot;OALSource::Play (AL_PLAYING state)  - kMQ_Retrigger added to MQ - OALSource = %ld&quot;</span>, (<span class="type">long</span> <span class="type">int</span>) mSelfToken);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="built_in">AddPlaybackMessage</span>(kMQ_Retrigger, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">SetPlaybackState</span>(kTransitionToRetrigger);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">case</span> AL_PAUSED:</span><br><span class="line">    <span class="built_in">Resume</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">case</span> kTransitionToPause:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LOG_MESSAGE_QUEUE     </span></span><br><span class="line">                <span class="built_in">DebugMessageN1</span>(<span class="string">&quot;OALSource::Play (kTransitionToPause state)  - kMQ_Resume added to MQ - OALSource = %ld&quot;</span>, (<span class="type">long</span> <span class="type">int</span>) mSelfToken);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">AddPlaybackMessage</span>((UInt32) kMQ_Resume, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">SetPlaybackState</span>(kTransitionToResume);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">case</span> kTransitionToStop:</span><br><span class="line">   <span class="keyword">case</span> kTransitionToRewind:</span><br><span class="line">    <span class="keyword">if</span> (mRampState != kRampingComplete)</span><br><span class="line">    &#123;</span><br><span class="line">     mRampState = kRampDown;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LOG_MESSAGE_QUEUE     </span></span><br><span class="line">     <span class="built_in">DebugMessageN1</span>(<span class="string">&quot;OALSource::Play (kTransitionToStop/kTransitionToRewind state)  - kMQ_Play added to MQ - OALSource = %ld&quot;</span>, (<span class="type">long</span> <span class="type">int</span>) mSelfToken);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="built_in">AddPlaybackMessage</span>(kMQ_Play, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">SetPlaybackState</span>(kTransitionToPlay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">   &#123;        </span><br><span class="line">    <span class="comment">// get the buffer q in a ready state for playback</span></span><br><span class="line">    <span class="built_in">PrepBufferQueueForPlayback</span>(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set up a mixer bus now</span></span><br><span class="line">    <span class="built_in">SetupMixerBus</span>();</span><br><span class="line">    CAStreamBasicDescription format;</span><br><span class="line">    UInt32                      propSize = <span class="built_in">sizeof</span>(format);</span><br><span class="line">    OSStatus result = noErr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mASARogerBeepEnable || mASADistortionEnable)</span><br><span class="line">    &#123; </span><br><span class="line">     mRenderElement = <span class="number">0</span>;</span><br><span class="line">     result = <span class="built_in">AudioUnitGetProperty</span>(mOwningContext-&gt;<span class="built_in">GetMixerUnit</span>(), kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, mCurrentPlayBus, &amp;format, &amp;propSize);</span><br><span class="line">      <span class="function">THROW_RESULT </span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">     <span class="title">if</span><span class="params">(mASARogerBeepEnable)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">      <span class="comment">// set AU format to mixer format for input/output</span></span><br><span class="line">      result = <span class="built_in">AudioUnitSetProperty</span> (mRogerBeepAU, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, <span class="number">0</span>, &amp;format, <span class="built_in">sizeof</span>(format));</span><br><span class="line">       THROW_RESULT</span><br><span class="line">      result = <span class="built_in">AudioUnitSetProperty</span> (mRogerBeepAU, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, <span class="number">0</span>, &amp;format, <span class="built_in">sizeof</span>(format));</span><br><span class="line">       THROW_RESULT</span><br><span class="line">      result = <span class="built_in">AudioUnitInitialize</span>(mRogerBeepAU);</span><br><span class="line">       THROW_RESULT</span><br><span class="line">      <span class="comment">// connect roger beep AU to 3D Mixer</span></span><br><span class="line">      result = <span class="built_in">AUGraphConnectNodeInput</span>(mOwningContext-&gt;<span class="built_in">GetGraph</span>(), mRogerBeepNode, <span class="number">0</span>, mOwningContext-&gt;<span class="built_in">GetMixerNode</span>(), mCurrentPlayBus);</span><br><span class="line">       <span class="function">THROW_RESULT </span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      <span class="title">if</span><span class="params">(!mASADistortionEnable)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">       <span class="comment">// connect render proc to unit if distortion is not enabled</span></span><br><span class="line">       result = <span class="built_in">AUGraphNodeInfo</span> (mOwningContext-&gt;<span class="built_in">GetGraph</span>(), mRogerBeepNode, <span class="literal">NULL</span>, &amp;mRenderUnit);</span><br><span class="line">        THROW_RESULT;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span>(mASADistortionEnable)</span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// set AU format to mixer format for input/output</span></span><br><span class="line">      result = <span class="built_in">AudioUnitSetProperty</span> (mDistortionAU, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, <span class="number">0</span>, &amp;format, <span class="built_in">sizeof</span>(format));</span><br><span class="line">       THROW_RESULT</span><br><span class="line">      result = <span class="built_in">AudioUnitSetProperty</span> (mDistortionAU, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, <span class="number">0</span>, &amp;format, <span class="built_in">sizeof</span>(format));</span><br><span class="line">       THROW_RESULT</span><br><span class="line">      result = <span class="built_in">AudioUnitInitialize</span>(mDistortionAU);</span><br><span class="line">       THROW_RESULT</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// distortion unit will always be first if it exists</span></span><br><span class="line">      result = <span class="built_in">AUGraphNodeInfo</span> (mOwningContext-&gt;<span class="built_in">GetGraph</span>(), mDistortionNode, <span class="literal">NULL</span>, &amp;mRenderUnit);</span><br><span class="line">       <span class="function">THROW_RESULT</span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function">      <span class="title">if</span><span class="params">(mASARogerBeepEnable)</span></span></span><br><span class="line"><span class="function">       result </span>= <span class="built_in">AUGraphConnectNodeInput</span>(mOwningContext-&gt;<span class="built_in">GetGraph</span>(), mDistortionNode, <span class="number">0</span>, mRogerBeepNode, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">       result = <span class="built_in">AUGraphConnectNodeInput</span>(mOwningContext-&gt;<span class="built_in">GetGraph</span>(), mDistortionNode, <span class="number">0</span>, mOwningContext-&gt;<span class="built_in">GetMixerNode</span>(), mCurrentPlayBus);</span><br><span class="line">        </span><br><span class="line">       THROW_RESULT</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     result = <span class="built_in">AUGraphUpdate</span>(mOwningContext-&gt;<span class="built_in">GetGraph</span>(), <span class="literal">NULL</span>);</span><br><span class="line">      THROW_RESULT</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">     mRenderUnit = mOwningContext-&gt;<span class="built_in">GetMixerUnit</span>();</span><br><span class="line">     mRenderElement = mCurrentPlayBus;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function">THROW_RESULT</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">SetPlaybackState</span><span class="params">(AL_PLAYING,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mRampState != kRampingComplete)</span><br><span class="line">        mRampState = kRampUp;</span><br><span class="line">    mResetBus = <span class="literal">true</span>;</span><br><span class="line">    mQueueIsProcessed = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// attach the notify and render procs to the first unit in the sequence</span></span><br><span class="line">    <span class="built_in">AddNotifyAndRenderProcs</span>();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (OSStatus result) &#123;</span><br><span class="line">  <span class="built_in">DebugMessageN2</span>(<span class="string">&quot;PLAY FAILED source = %ld, err = %ld\n&quot;</span>, (<span class="type">long</span> <span class="type">int</span>) mSelfToken, (<span class="type">long</span> <span class="type">int</span>)result);</span><br><span class="line">  <span class="keyword">throw</span> (result);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>play的阶段可以分三步</p><ol><li>确认Render状态，如果在rendering就上锁。</li><li>确认长度，如果为0则直接返回</li><li>根据当前播放状态设置所需的内部状态。</li></ol><p>尽管对外的播放状态只有4种，但是实际的内部状态有许多种。Play函数将根据不同的初始状态统合成预想状态，然后在render处理时根据对应状态执行音频播放。</p><p>所以这里涉及到新版OpenAL中一个重大变化，播放逻辑的统一处理：在正常的<code>AUGraphUpdate</code>中对所有需要render的音频做render处理。如果查看旧版本的OpenAL源码的话会发现它其实是一步处理的。</p><h3 id="可能的崩溃点"><a href="#可能的崩溃点" class="headerlink" title="可能的崩溃点"></a>可能的崩溃点</h3><p>在大多数情况下，try-catch会帮我们把alError给暴露出来，但是有许多情况实际上是没有执行play-render逻辑的。在这里我需要梳理一下情况。</p><ol><li><code>GetQLengthPriv = 0</code>时，不会做任何处理，直接返回，这时候状态不会做任何改变，也不会播放。</li><li><code>AddPlaybackMessage</code>存在消息队列中，并且 MessageQ 和运行状态不同步。</li><li><code>PrepBufferQueueForPlayback</code>只会返回bool状态，但是这里并没有做判断，所以并不清楚bufferq的状态</li><li><code>SetupMixerBus</code>没有做判断，并不能从这里判断mixer的状态。</li></ol><p>在这些情况下，音频的状态并不会从<code>AL_STOPPED</code>转为播放状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近工作上对于音频有一些issue需要处理，但是OpenAL的文档相当模糊，也鲜有StackOverflow的回答，无奈之下我决定依据Apple最新的&lt;a href=&quot;https://opensource.apple.com/tarballs/OpenAL/&quot;&gt;OpenAL</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在MacOSX上搭建本地测试服务器的踩坑</title>
    <link href="http://timlyeee.github.io/2022/04/24/apache2ServerOnMacOSX/"/>
    <id>http://timlyeee.github.io/2022/04/24/apache2ServerOnMacOSX/</id>
    <published>2022-04-24T03:18:12.000Z</published>
    <updated>2023-01-05T12:56:11.061Z</updated>
    
    <content type="html"><![CDATA[<p>当在开发微信小游戏，或者部署一些云端资源时往往需要自定义测试服务器，以免抢占云端资源。之前有在Windows上使用Apache2搭建过一个localhost服务器，但是由于有在Mac上面开发的需求，所以转到Mac环境中又做了一遍，结果在这里踩了几个坑。</p><span id="more"></span><h2 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a>搭建服务器</h2><p>实际上MacOS环境中本身就已经配置好了环境，这意味着我们不需要另行下载Apache等工具。在这里推荐一篇文章可以对应不同版本的MacOSX进行微调。</p><blockquote><p><a href="https://discussions.apple.com/docs/DOC-3083">Setting up a local web server on a Mac</a></p></blockquote><p>但是，如果是像我一样的小白，在依照上述方法创建好自己的个人文件夹并试图从外部设备打开时，则会遇到<code>Forbidden, you don&#39;t have permission to access this resource</code> 的错误。</p><h2 id="Access-Forbidden-的坑"><a href="#Access-Forbidden-的坑" class="headerlink" title="Access Forbidden 的坑"></a>Access Forbidden 的坑</h2><p>其实原因在于文件夹的配置。在文章中有提到可以通过建立自己的文件夹而不是默认文件路径存储资源，因为MacOSX 10.7之后不会自动创建文件夹。而它给出的配置文件如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/Users/&lt;your short user name&gt;/Sites/&quot;&gt; </span><br><span class="line">  AddLanguage en .en </span><br><span class="line">  AddHandler perl-script .pl </span><br><span class="line">  PerlHandler ModPerl::Registry </span><br><span class="line">  Options Indexes MultiViews FollowSymLinks ExecCGI </span><br><span class="line">  AllowOverride None </span><br><span class="line">  Require host localhost #With this line, only host, localhost can access the Sites folder.</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>如果加上Require的设置，就会出现即便是本机，输入自己的ip也依然无法访问的情况。所以只要修改这一栏就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/Users/&lt;your short user name&gt;/Sites/&quot;&gt; </span><br><span class="line">  AddLanguage en .en </span><br><span class="line">  AddHandler perl-script .pl </span><br><span class="line">  PerlHandler ModPerl::Registry </span><br><span class="line">  Options Indexes MultiViews FollowSymLinks ExecCGI </span><br><span class="line">  AllowOverride None </span><br><span class="line">  # Require host localhost #With this line, only host, localhost can access the Sites folder.</span><br><span class="line">  Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;当在开发微信小游戏，或者部署一些云端资源时往往需要自定义测试服务器，以免抢占云端资源。之前有在Windows上使用Apache2搭建过一个localhost服务器，但是由于有在Mac上面开发的需求，所以转到Mac环境中又做了一遍，结果在这里踩了几个坑。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>简单的CMake小项目</title>
    <link href="http://timlyeee.github.io/2021/07/19/petit-cmake/"/>
    <id>http://timlyeee.github.io/2021/07/19/petit-cmake/</id>
    <published>2021-07-19T15:11:14.000Z</published>
    <updated>2023-01-05T12:56:11.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近对于vs和cmake的熟悉程度日益加深并且对于各种项目更加熟悉之后，想试着在以往的项目中加入相关的元素，使其能够在各种环境下运行，比如不依赖特定的vs toolset和sdk，否则比如之前写的一个vs项目，当真是换了一台机器就不能运行了。</p><p>当然我想这也是大部分项目对于项目结构的一个最低要求。比如v8的项目或者libuv的第三方库实际上并没有对windows端有什么特例，而是单纯的从configure或者cmake开始配置。所以这次这篇文章想简单的记录一下自己写的第一个小的cmakelist.txt并且剖析一下其中的原理。</p><span id="more"></span><h2 id="cmake的必要条件"><a href="#cmake的必要条件" class="headerlink" title="cmake的必要条件"></a>cmake的必要条件</h2><p>首先一个项目最需要明确的有两点，就是项目的名称和使用的cmake版本。</p><h3 id="环境声明"><a href="#环境声明" class="headerlink" title="环境声明"></a>环境声明</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">set</span>(PROJECT_NAME <span class="string">&quot;petitEngine&quot;</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> CXX)</span><br></pre></td></tr></table></figure><p>以我的小opengl项目举例，我所认定的cmake版本必须是3.8以上并且语言是c++。所以我的环境设置就通过这几行代码来声明。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>需要注意的是我们的项目名称的声明方法实际上是用set做的，而cmake中本身也有很多已经命名过的变量，比如PROJECT_NAME就是特指项目名称。</p><p>在通常cmake文件中所有的变量都是通过set去初始化的，而后续对于设置的值的链接或者包含头文件的操作则需要用${}包含起来才能使用。</p><h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><p>接下来我们要确认有哪些文件是本项目的源代码，并且需要和依赖文件区分开来。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(PROJ_SOURCES </span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="keyword">include</span>/main.cpp</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(PROJECT_NAME <span class="variable">$&#123;PROJ_SOURCES&#125;</span>)</span><br></pre></td></tr></table></figure><p>假设我们有一个main文件并且需要作为源文件导入到vs项目中，我们需要首先设置一个变量x，在这里我命名为Proj_source，并且将main的路径作为第二个变量写入。当然后续可以跟任意多的文件，只需要保证第一个变量是名称就行。</p><p>接下来我们使用add_executable命令将这些源文件赋值到PROJECT_NAME中，表明这是它的源代码。当项目生成后，我们就可以在项目的路径中找到这些文件了。</p><h3 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(glew STATIC IMPORTED GLOBAL)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glew PROPERTIES</span><br><span class="line">    IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/glew-<span class="number">2.1</span>.<span class="number">0</span>/lib/Release/x64/glew32s.lib</span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_library</span>(glfw STATIC IMPORTED GLOBAL)</span><br><span class="line"><span class="keyword">set_target_properties</span>(glfw PROPERTIES</span><br><span class="line">    IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/glfw-<span class="number">3.3</span>.bin.WIN64/lib-vc2017/glfw3.lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我的项目中依赖到了几个关键的库，比如glew和glfw来作为opengl的接口。所以我用add_library的方式将它们添加到各自的命名项中，注意此时不需要set来初始化变量。</p><p>同时在add_library中STATIC表示该项是以静态库的方式导入，如果是动态库则使用SHARED。</p><p>声明了几个库之后需要将它们链接到项目中，同时也可以添加一些别的必要库比如系统库，在cmake的过程中这些库即使没有被用户声明也是可以找到的。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(PROJECT_NAME PUBLIC </span><br><span class="line">glfw </span><br><span class="line">glew </span><br><span class="line">opengl32)</span><br><span class="line"><span class="keyword">target_include_directories</span>(PROJECT_NAME PUBLIC</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/glfw-<span class="number">3.3</span>.bin.WIN64/<span class="keyword">include</span>/GLFW</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/glew-<span class="number">2.1</span>.<span class="number">0</span>/<span class="keyword">include</span>/GL                           </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们不仅需要其静态库，同样需要头文件的支持，所以在link的同时可以使用target_include_directories命令来将头文件包含进去。这样就可以直接用</p><figure class="highlight cxx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glew.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>的方法来包含而不需要添加相对路径。相对而言更加轻松。</p><h3 id="cmake文件到vs项目"><a href="#cmake文件到vs项目" class="headerlink" title="cmake文件到vs项目"></a>cmake文件到vs项目</h3><p>当我们安装了cmake，visual studio和拥有了一个cmake文件之后，我们就可以省略繁琐的gcc命令而直接使用cmake命令来帮助我们完成操作了。<br>事实上我们同样可以通过cmake gui的方式来构建项目，但最终都是要回归代码的所以我在这里直接写shell脚本的写法了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -B out/x64\</span><br><span class="line">     -A x64 \</span><br><span class="line">     -G<span class="string">&quot;Visual Studio 15 2017&quot;</span></span><br></pre></td></tr></table></figure><p>通过上述脚本，用-B指定项目所在目录，用-A指定32位或者64位架构，用-G表示用哪种编译器，就可以生成我们的项目了。注意的是，这个脚本只在cmakelist.txt文件同级的目录下可用，如果在别的目录则需要加上-S选项来指定cmakelist.txt文件所在位置。</p><p>总之，这些都可以在cmake –help中获取。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>虽然但是，各种第三方开源库的编译仍然很麻烦，我所掌握的只是一些皮毛，在cmake中我们还可以控制各种宏的生成以及同样可以做if判断，这些同样使得我们很多依赖的库通过不同的构建选项编译出来的lib文件都不相同。</p><p>一想到我虽然把第三方库都编出来了，但却在运行时崩溃，就免不了一阵头大。。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近对于vs和cmake的熟悉程度日益加深并且对于各种项目更加熟悉之后，想试着在以往的项目中加入相关的元素，使其能够在各种环境下运行，比如不依赖特定的vs toolset和sdk，否则比如之前写的一个vs项目，当真是换了一台机器就不能运行了。&lt;/p&gt;
&lt;p&gt;当然我想这也是大部分项目对于项目结构的一个最低要求。比如v8的项目或者libuv的第三方库实际上并没有对windows端有什么特例，而是单纯的从configure或者cmake开始配置。所以这次这篇文章想简单的记录一下自己写的第一个小的cmakelist.txt并且剖析一下其中的原理。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Git常用命令以及使用场景</title>
    <link href="http://timlyeee.github.io/2021/06/27/gitNormalSit/"/>
    <id>http://timlyeee.github.io/2021/06/27/gitNormalSit/</id>
    <published>2021-06-27T14:52:24.000Z</published>
    <updated>2023-01-05T12:56:11.062Z</updated>
    
    <content type="html"><![CDATA[<p>Git在日常工作场景中非常常见，但是对于其类似的使用场景大多数新手会十分懵逼，此文我希望能够整理一些常见的使用场景，警示自己并告知后来者</p><span id="more"></span><h2 id="Git-Checkout-amp-amp-Git-Reset-amp-amp-Git-Stash"><a href="#Git-Checkout-amp-amp-Git-Reset-amp-amp-Git-Stash" class="headerlink" title="Git Checkout &amp;&amp; Git Reset &amp;&amp; Git Stash"></a>Git Checkout &amp;&amp; Git Reset &amp;&amp; Git Stash</h2><p>一个比较常用的场景是切换分支，因为同一个项目会有多个不同的目的。从而创建出不同的分支。当我们在A分支工作时，突然接到一个需求需要去帮忙review B分支，或者帮忙测试B分支。这时候重新去下载一个分支是很愚蠢的一件事。</p><p>我们可以对一个刚刚Git clone下来的项目进行Git Checkout B的操作，因为此时没有任何修改。</p><p>但是如果我们已经在本分支上工作过一段时间，我们可以怎么做呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Git Add .</span><br><span class="line">Git Commit -m &quot;commit message&quot;</span><br><span class="line">Git Push</span><br><span class="line">Git Checkout B</span><br></pre></td></tr></table></figure><p>这其实是一个很笨重的做法，这不仅会多出一个不太重要的commit搞混思路，也会让仓库多一个需要记录的内容。所以我们可以在本地临时保存这个修改，即使用Git Stash命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Git Stash</span><br><span class="line">Git Checkout B</span><br><span class="line"><span class="comment"># After Operation</span></span><br><span class="line">Git Checkout A</span><br><span class="line">Git Pop</span><br></pre></td></tr></table></figure><p>在操作结束之后可以Git Pop原来保存的内容，并继续在原来的分支上工作</p><h2 id="Git-Rebase-amp-amp-Git-Merge"><a href="#Git-Rebase-amp-amp-Git-Merge" class="headerlink" title="Git Rebase &amp;&amp; Git Merge"></a>Git Rebase &amp;&amp; Git Merge</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git在日常工作场景中非常常见，但是对于其类似的使用场景大多数新手会十分懵逼，此文我希望能够整理一些常见的使用场景，警示自己并告知后来者&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何从零开始编译二进制静态库或动态库</title>
    <link href="http://timlyeee.github.io/2021/06/20/how2CompileALibrary-md/"/>
    <id>http://timlyeee.github.io/2021/06/20/how2CompileALibrary-md/</id>
    <published>2021-06-19T16:23:02.000Z</published>
    <updated>2023-01-05T12:56:11.062Z</updated>
    
    
    
    
    
    <category term="Cmake, dll, lib" scheme="http://timlyeee.github.io/tags/Cmake-dll-lib/"/>
    
  </entry>
  
  <entry>
    <title>通过创建并监听子进程并用pywinauto进行测试</title>
    <link href="http://timlyeee.github.io/2021/05/23/pywinautoAndSubprocess/"/>
    <id>http://timlyeee.github.io/2021/05/23/pywinautoAndSubprocess/</id>
    <published>2021-05-23T12:42:39.000Z</published>
    <updated>2023-01-05T12:56:11.065Z</updated>
    
    <content type="html"><![CDATA[<p>恭喜我终于找到工作啦！一直以为自己技术栈很浅所以不太容易来着。现在是做游戏引擎开发相关的工作，还在熟悉阶段，但是确实是我热衷的方面了。</p><p>最近在和测试组对接工作。进行测试用例的维护和原生平台的bug排查。有几个测试用例在win32平台上出了错，然而我源代码都还没搞懂。更糟糕的是，测试组那边并没有保留测试时编译的可执行文件，这让我无从下手。</p><p>为了让后续的排查更方便，我和测试组沟通让他们保留测试时的exe文件。顺便用监听exe日志输出的方式排查文件消息。</p><span id="more"></span><h2 id="cmd中的输出"><a href="#cmd中的输出" class="headerlink" title="cmd中的输出"></a>cmd中的输出</h2><p>这需要明白一个事实，就是exe文件实际上是会有控制台输出的。在cmd中用下列命令就可以打印并显示。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.exe &gt; log.txt</span><br></pre></td></tr></table></figure><p>但是这个命令在powershell中是不可用的，会卡死。毕竟powershell本质是shell的一种而不是prompt。</p><h2 id="基于cmd的pywinauto"><a href="#基于cmd的pywinauto" class="headerlink" title="基于cmd的pywinauto"></a>基于cmd的pywinauto</h2><p>对于引擎的测试，大部分是通过图像对比的方式进行的。这里不得不提到一个工具库就是pywinauto。他可以直接获取程序运行时的各种控件并点击然后测试。继而通过截图对比测试预期效果和实际效果的差距。</p><p>创建一个pywinauto的程序需要用下面的python代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = pywinauto.application().start(<span class="string">&quot;test.exe&quot;</span>)</span><br></pre></td></tr></table></figure><p>其本身调用的是cmd的命令，即其可以写成下面的形式并输入参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = pywinauto.application().start(cmd_line=<span class="string">&quot;test.exe arg1 arg2&quot;</span>)</span><br></pre></td></tr></table></figure><p>于是我们理所当然的希望它能够直接和第一部分说的cmd命令一样打印日志出来。但是很可惜的是，pywinauto并不能做到这件事，也没有原生方法支持这件事。</p><p><a href="https://github.com/pywinauto/pywinauto/issues/1075">https://github.com/pywinauto/pywinauto/issues/1075</a></p><p>所以这时候就需要用到subprocess来帮助我们。</p><h2 id="利用subprocess进行监听"><a href="#利用subprocess进行监听" class="headerlink" title="利用subprocess进行监听"></a>利用subprocess进行监听</h2><p>我问了前辈，如果是在内部编辑器里面，是会用什么方法去监听控制台输出呢？答曰：创建并监听子进程。python同理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = subprocess.popen(<span class="string">&quot;test.exe&quot;</span>)</span><br><span class="line">app = pywinauto.application().connect(app)</span><br></pre></td></tr></table></figure><p>pywinauto虽然并没有原生的方法进行监听，但是可以通过连接到现有进程进行测试。需要注意的是，subprocess在打开进程后，代码会卡住，因为这个打开操作并非异步的，需要在方法中创建一个进程，并且使用异步的方法进行监听。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;恭喜我终于找到工作啦！一直以为自己技术栈很浅所以不太容易来着。现在是做游戏引擎开发相关的工作，还在熟悉阶段，但是确实是我热衷的方面了。&lt;/p&gt;
&lt;p&gt;最近在和测试组对接工作。进行测试用例的维护和原生平台的bug排查。有几个测试用例在win32平台上出了错，然而我源代码都还没搞懂。更糟糕的是，测试组那边并没有保留测试时编译的可执行文件，这让我无从下手。&lt;/p&gt;
&lt;p&gt;为了让后续的排查更方便，我和测试组沟通让他们保留测试时的exe文件。顺便用监听exe日志输出的方式排查文件消息。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从互斥机制到锁</title>
    <link href="http://timlyeee.github.io/2021/04/05/locks-2/"/>
    <id>http://timlyeee.github.io/2021/04/05/locks-2/</id>
    <published>2021-04-05T02:20:17.000Z</published>
    <updated>2023-01-05T12:56:11.064Z</updated>
    
    <content type="html"><![CDATA[<p>从机制和原理讲到锁，自然而然的将会从想法到实现机制进行转变。因此，本节将注重阐述各种锁的区别和简单的python代码实现。</p><span id="more"></span><h2 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h2><p>虽然我学过JAVA，但是很多并发编程的知识我是一窍不通。但是并发这个东西无论是JAVA还是C++编程应该都是存在的。锁作为并发共享数据，保证线程同步性的工具，是需要我去仔细钻研的。</p><p><img src="locks.png" alt="锁的基本原理"></p><p>我们说对一个变量上锁，实际上就是指当进程想要使用某一部分资源的时候，如果是独占性资源，需要首先把这个资源锁上占为己有，直到释放。以此原理而诞生的锁有很多种，首先就是互斥锁。互斥的概念我们上一章有讲到，所以直接进入正题。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制。线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定&#x2F;非锁定</p><p><strong>mutex</strong>（mutual exclusive）即<strong>互斥量（互斥体）</strong>。也便是常说的互斥锁。</p><p><strong>mutex是睡眠等待（sleep waiting）类型的锁，当线程抢互斥锁失败的时候，线程会陷入休眠。</strong></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>小的概念补充：进程调度。</p><p>无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p><blockquote><p>进程调度会把“缺乏资源”的进程置于休眠队列、又要把休眠队列中资源要求可以满足的进程置于等待队列——然后时间片一到就会调度运行。</p></blockquote><blockquote><p>一般学到这里，我们都会觉得“资源”嘛，就是磁盘访问、网络通信之类东西：它们忙不忙，操作系统自然是知道的……其实不然。操作系统在这里做了“归一化”处理，它压根懒得知道你在等什么（不然进程调度就实现的过于复杂了）。所谓的“资源”，在进程调度逻辑看来，就是一个个“锁”——请求锁得不到满足，就是“缺乏资源”；锁被释放了，请求它的进程显然就有“资源”可用了。。</p></blockquote><blockquote><p>来自 <a href="https://www.zhihu.com/question/66733477/answer/246760992">https://www.zhihu.com/question/66733477/answer/246760992</a></p></blockquote><p>那么互斥锁就是相对两个进程而言的对同一资源的利用。</p><p>threading模块中定义了Lock类，可以方便的处理锁定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定</span></span><br><span class="line">mutex.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果这个锁之前是没有上锁的，那么acquire不会堵塞</li><li>如果在调用acquire对这个锁上锁之前 它已经被其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止</li></ul><h3 id="使用互斥锁完成2个线程对同一个全局变量各加9999999-次的操作"><a href="#使用互斥锁完成2个线程对同一个全局变量各加9999999-次的操作" class="headerlink" title="使用互斥锁完成2个线程对同一个全局变量各加9999999 次的操作"></a>使用互斥锁完成2个线程对同一个全局变量各加9999999 次的操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span> </span><br><span class="line"><span class="comment"># 创建一个互斥锁，默认为未上锁状态</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">num</span>):</span><br><span class="line">        <span class="keyword">global</span> g_num</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    </span><br><span class="line">                mutex.acquire()</span><br><span class="line">                g_num += <span class="number">1</span></span><br><span class="line">                mutex.release()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;--test1, g_num = %d--&quot;</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">num</span>):</span><br><span class="line">        <span class="keyword">global</span> g_num</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    </span><br><span class="line">                mutex.acquire()</span><br><span class="line">                g_num += <span class="number">1</span></span><br><span class="line">                mutex.release()</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;--test2, g_num = %d--&quot;</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;--创建线程之前, g_num = %d--&quot;</span> % g_num)</span><br><span class="line"></span><br><span class="line">        t1 = threading.Thread(target=test1, args=(<span class="number">9999999</span>,))</span><br><span class="line">        t1.start()</span><br><span class="line"></span><br><span class="line">        t2 = threading.Thread(target=test2, args=(<span class="number">9999999</span>,))</span><br><span class="line">        t2.start()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;最终结果为：g_num=%d&quot;</span> % g_num)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--创建线程之前, g_num = 0--</span><br><span class="line">--test1, g_num = 19580251--</span><br><span class="line">--test2, g_num = 19999998--</span><br><span class="line">最终结果为：g_num=19999998 </span><br></pre></td></tr></table></figure><p>从代码里可见，锁的创建方法并不与所控制的变量相绑定，而是单独创建即可。而两个进程争夺的也不是变量的控制权，而是锁的控制权。获得锁的控制权后进而改变变量。</p><p>锁的好处：</p><ul><li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li></ul><p>锁的坏处：</p><ul><li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li><li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p><p>尽管死锁很少发生，但一旦发生就会造成应用的停止响应。下面看一个死锁的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span>(threading.Thread):</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对mutex1上锁</span></span><br><span class="line">mutex1.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># mutex1上锁后，延迟1秒，等待另外一个线程，把mutex2上锁</span></span><br><span class="line"><span class="built_in">print</span>(self.name + <span class="string">&quot; up&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时这里会堵塞，因为mutex2已经被另外的线程抢先上锁了</span></span><br><span class="line">mutex2.acquire()</span><br><span class="line"><span class="built_in">print</span>(self.name + <span class="string">&quot; down&quot;</span>)</span><br><span class="line">mutex2.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对mutex1解锁</span></span><br><span class="line">mutex1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span>(threading.Thread):</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对mutex2上锁</span></span><br><span class="line">mutex2.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># mutex2上锁后，延迟1秒，等待另外一个线程，把mutex1上锁</span></span><br><span class="line"><span class="built_in">print</span>(self.name + <span class="string">&quot; up&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时这里会堵塞，因为mutex1已经被另外的线程抢先上锁了</span></span><br><span class="line">mutex1.acquire()</span><br><span class="line"><span class="built_in">print</span>(self.name + <span class="string">&quot; down&quot;</span>)</span><br><span class="line">mutex1.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对mutex2解锁</span></span><br><span class="line">mutex2.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutex1 = threading.Lock()</span><br><span class="line">mutex2 = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">t1 = MyThread1()</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = MyThread2()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>两个进程互相拥有一个锁的情况下去寻求彼此的锁却不释放。其实本身代码就是有毛病的。但是这确实是死锁状态了。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p><p>简单来想的话，甚至不需要编程就能解释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (抢锁(lock) == 没抢到) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。但是如果是在长时间共同操作一个变量的话，互斥锁也是一种选择。</p><p>换而言之，互斥锁其实是自旋锁的进一步利用，因为自旋锁如果没抢到的话会一直循环，而mutex则是睡眠并等待锁解开后的提醒。</p><p>锁的结果和我们之前学的阻塞是一样的，如果抢不到锁，就会被阻塞住。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。所有读写锁的实现<strong>必须确保写操作对读操作的内存影响</strong>。换句话说，<strong>一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容</strong>。</p><p>读写锁比互斥锁允许对于共享数据更大程度的并发。每次只能有一个写线程，但是同时可以有多个线程并发地读数据。ReadWriteLock适用于读多写少的并发情况。</p><blockquote><p>当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权, 但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁.</p></blockquote><p>我们用python来对读写锁进行模拟的话，实际上就是设置一个锁组。</p><blockquote><p>参考 <a href="https://segmentfault.com/a/1190000016900930">https://segmentfault.com/a/1190000016900930</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RWlock</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._lock = threading.Lock()</span><br><span class="line">        self._extra = threading.Lock()</span><br><span class="line">        self.read_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_acquire</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> self._extra:</span><br><span class="line">            self.read_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.read_num == <span class="number">1</span>:</span><br><span class="line">                self._lock.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_release</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> self._extra:</span><br><span class="line">            self.read_num -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.read_num == <span class="number">0</span>:</span><br><span class="line">                self._lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_acquire</span>(<span class="params">self</span>):</span><br><span class="line">        self._lock.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_release</span>(<span class="params">self</span>):</span><br><span class="line">        self._lock.release()</span><br></pre></td></tr></table></figure><p>self.read_num 用来保存获得读锁的线程数，这个属性属于临界区，对其操作也要加锁，所以这里需要一个保护内部数据的额外的锁 self._extra 。</p><p>但是这个锁是不公平的。理想情况下，线程获得所的机会应该是一样的，不管线程是读操作还是写操作。而从上述代码可以看到，读请求都会立即设置 self.read_num +&#x3D; 1，不管有没有获得锁，而写请求想要获得锁还得等待 read_num 为 0 。</p><p>所以写者还在后续的改进中加入了条件机制。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>锁的机制其实很好理解，而且大部分语言中也自带了库可以调用，需要注意的还是应用场景和避免死锁的问题。</p><hr><p>我发现掌握C#和C++在笔试的时候会有很多难受的地方，例如很多东西不能直接使用。尤其是自己处理IO的话，很麻烦。但是我还是偏爱C++。</p><p>为了处理IO的题目，我会稍微练习一下python，作为备选语言。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从机制和原理讲到锁，自然而然的将会从想法到实现机制进行转变。因此，本节将注重阐述各种锁的区别和简单的python代码实现。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>同步，互斥，阻塞</title>
    <link href="http://timlyeee.github.io/2021/03/11/locks-1/"/>
    <id>http://timlyeee.github.io/2021/03/11/locks-1/</id>
    <published>2021-03-11T09:32:01.000Z</published>
    <updated>2023-01-05T12:56:11.063Z</updated>
    
    <content type="html"><![CDATA[<p>昨日的笔试中被问到读写锁的定义和用途，突然发现读写和锁这两个词分开来我很熟悉，但合在一块儿我就一脸懵逼了。所以今天我特意花了一大部分时间来研究这些机制和各种锁。尽管网上大家说的都不太一样，但我还是梳理了一下我所理解的同步，互斥，阻塞和锁。但是锁的内容有些繁杂，我们先分清同步和阻塞这两个概念。</p><span id="more"></span><h2 id="程序运行的基本方式"><a href="#程序运行的基本方式" class="headerlink" title="程序运行的基本方式"></a>程序运行的基本方式</h2><p>在动笔之前，我需要强调的是其实编程是一种操作内容的手段，本质是对内存空间的修改和读取。进而的，各种程序之间肯定会起冲突，这一点无法避免。</p><p>这就好比排队，人不能容忍插队的现象，计算机同样不能容忍各程序争先恐后的抢夺同一部分资源或文件。我们作为程序员，对于自己的程序也无法容忍因为顺序问题导致的毛病。</p><p>所以为了完善这些分配法则，我们创造出了一系列的名词，一系列的算法。这些东西并没有什么高低之分，只是让我们在不同场景下能够方便的解决问题。</p><p>而最笼统的名词，就是同步和异步。</p><h2 id="同步，异步"><a href="#同步，异步" class="headerlink" title="同步，异步"></a>同步，异步</h2><p>同步和异步其实是一种<strong>机制</strong>。他们没有约定俗成的写法和实现方法，只是一种目的！</p><p>同步其实就是顺序化，在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。</p><p>例如登陆，必须等待验证完成后才能跳转界面。</p><p>异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。例如网页加载时的图片加载。</p><p>同时，同步和异步是针对应用程序和内核的交互而言的。当然这一点也是相对而言的，它们的关系也可以是用户端网页和服务器，应用程序和操作系统等。</p><p>当我们说我们要用异步机制来解决问题时，我们可能会用到async函数等方法，并且用await来表明等待。但我们同样可以另开一个线程来解决这个问题。Ca depende.</p><p>但阻塞和互斥的概念就相对比较固定了</p><h2 id="阻塞，非阻塞"><a href="#阻塞，非阻塞" class="headerlink" title="阻塞，非阻塞"></a>阻塞，非阻塞</h2><p>我曾经学过阻塞，但是我们上课所讲的阻塞实际上也是一种机制，在各种编程语言中都可以灵活变通使用。但不知道为何，在网上大多数人口中就变成了内核的处理模式。</p><p>所以我挑了一个和我观点比较接近的知乎高分答案来帮助我解答这个疑惑。</p><blockquote><p>怎样理解阻塞非阻塞与同步异步的区别？ - 萧萧的回答 - 知乎<br><a href="https://www.zhihu.com/question/19732473/answer/241673170">https://www.zhihu.com/question/19732473/answer/241673170</a></p></blockquote><p>在这个答案之前，我需要先复习一些状态机的知识。</p><p><img src="basicMode.jpg" alt="基本的状态机"></p><p>我最开始接触状态机这个术语是在学电路的时候。但是状态机的概念却可以被广泛应用于各个领域，比如游戏AI。游戏AI的个体状态就是在不停的往来反复的。同理对于构成游戏AI的各个变量，也拥有这样一种状态。对于利用系统资源或者全局变量的各个函数，同样也会陷入到各种状态。</p><p>而阻塞和非阻塞是针对于进程在访问数据的时候，根据<strong>IO操作的就绪状态</strong>来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。从这个层面上来理解，进程的情况也是遵循状态机模型的。</p><p>说到进程，其进入阻塞状态的最常见常见和最常用例子就是信息阻塞，即<strong>用户态应用通过IPC机制通过内核发送消息时的阻塞</strong>。适当的回顾一下用户态和内核态，即用户空间和内核空间。</p><p><img src="kernal.jpg" alt="用户态和内核态通信缩略图"></p><p>从图中可以看到，信息在用户空间传递到内核时，基于内核的处理方式，信息是不一定到达的。如果到这一步为止，我们就可以说，信息被阻塞了。当然，简单这么理解肯定是不够的，因为对于进程而言，信息的阻塞和自己有关，但在多个进程之间切换则与内核有关。</p><blockquote><p>操作系统在进行进切换时，需要进行一系列的内存读写操作， 这带来了一定的开销：对于一个运行着 UNIX 系统的现代 PC 来说， 进程切换通常至少需要花费 300 us 的时间</p></blockquote><p>在我的理解里，进程切换就意味着当前进程被挂起，尽管我们可能无法感知，但是对于计算机而言，或者说对于进程而言，时间是很漫长的。</p><p>所以接下来就是深入理解阻塞了。</p><blockquote><p>进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是阻塞的或非阻塞的 – 也被称为同步或异步的：</p><ul><li>阻塞式发送（blocking send）. 发送方<em>进程</em>会被一直阻塞， 直到消息被接受方进程收到。</li><li>非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。</li><li>阻塞式接收（blocking receive） 接收方调用 receive() 后一直阻塞， 直到消息到达可用。</li><li>非阻塞式接受（nonblocking receive） 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。</li></ul></blockquote><p><img src="blockStateGraph.jpg" alt="阻塞状态循环图"></p><blockquote><p>我们所说的 “阻塞”是指进程在发起了一个<strong>系统调用（System Call）</strong> 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为<strong>等待 （waiting）</strong>状态， 以确保它不会被调度执行， 占用 CPU 资源。</p></blockquote><ul><li>友情提示： 在任意时刻， 一个 CPU 核心上（processor）只可能运行一个进程 。</li></ul><p>那么为什么阻塞明明是一个进程的挂起操作，却总是和IO连在一起讨论呢？原因是， 阻塞这个词是与系统调用 System Call 紧紧联系在一起的， 因为要让一个进程进入 等待（waiting） 的状态, 要么是它主动调用 wait() 或 sleep() 等挂起自己的操作， 另一种就是它调用 System Call, 而** System Call 因为涉及到了 I&#x2F;O 操作， 不能立即完成，** 于是内核就会先将该进程置为等待状态， 调度其他进程的运行， 等到 它所请求的 I&#x2F;O 操作完成了以后， 再将其状态更改回 ready 。</p><p>操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， <strong>操作系统</strong>发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。</p><p>在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I&#x2F;O 设备的中断信号后， 再来读取相应的设备缓冲区。 但是，大部分操作系统<strong>默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口</strong>， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执行顺序和编写顺序是一致的）。但同样， 现在的大部分操作系统也会提供非阻塞I&#x2F;O 系统调用接口（Nonblocking I&#x2F;O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值， 表示有多少bytes 的数据被成功读取（或写入）。</p><blockquote><p>非阻塞I&#x2F;O 系统调用( nonblocking system call )的另一个替代品是 异步I&#x2F;O系统调用 （asychronous system call）。 与非阻塞 I&#x2F;O 系统调用类似，asychronous system call 也是会立即返回， 不会等待 I&#x2F;O 操作的完成， 应用程序可以继续执行其他的操作， 等到 I&#x2F;O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。</p></blockquote><blockquote><p>此处， 非阻塞I&#x2F;O 系统调用( nonblocking system call ) 和 异步I&#x2F;O系统调用 （asychronous system call）的区别是：</p><ul><li>一个非阻塞I&#x2F;O 系统调用 read() 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。</li><li>而异步I&#x2F;O系统调用 read（）结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。</li></ul></blockquote><p><img src="blockAsync.jpg" alt="同步IO和异步IO"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>阻塞&#x2F;非阻塞， 同步&#x2F;异步的概念要注意讨论的上下文：<ul><li>在进程通信层面， 阻塞&#x2F;非阻塞， 同步&#x2F;异步基本是同义词， 但是需要注意区分讨论的对象是发送方还是接收方。</li><li>发送方阻塞&#x2F;非阻塞（同步&#x2F;异步）和接收方的阻塞&#x2F;非阻塞（同步&#x2F;异步） 是互不影响的。</li><li>在 IO 系统调用层面（ IO system call ）层面， 非阻塞 IO 系统调用 和 异步 IO 系统调用存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 但是都属于非阻塞系统调用（ non-blocing system call ）</li></ul></li><li>非阻塞系统调用（non-blocking I&#x2F;O system call 与 asynchronous I&#x2F;O system call） 的存在可以用来实现线程级别的 I&#x2F;O 并发， 与通过多进程实现的 I&#x2F;O 并发相比可以减少内存消耗以及进程切换的开销。</li></ol><h3 id="老张和茶壶"><a href="#老张和茶壶" class="headerlink" title="老张和茶壶"></a>老张和茶壶</h3><p>现在我们回到这个经典的例子。</p><p>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p><p>1 老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己有点傻</p><p>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。</p><p>3 老张把响水壶放到火上，立等水开。（异步阻塞）老张觉得这样傻等意义不大</p><p>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。</p><p>在这个例子中，其实老张就是发送方应用。当老张在等待水烧开时，其实是等待内核态返回值。所以老张是阻塞的。同理，不等待的老张就是非阻塞的。</p><p>而对于水壶而言，普通水壶和响水壶对应的只是两种方式，无论哪一种，本质没有区别，等需要等待一段时间后才能返回，但是“响”这个动作是同步异步的关键，它代表了对于提水壶这个动作的处理方式。</p><p>因为老张时不时的看水有没有开，其实是在做一个while循环，这是对于本进程而言的处理方式，而响水壶只是提供了另一个处理方式而已。即同步异步的处理方式了。</p><h2 id="编程中的同步和异步"><a href="#编程中的同步和异步" class="headerlink" title="编程中的同步和异步"></a>编程中的同步和异步</h2><p>我们说到同步异步只是一只手段或者是方式，对于应用中的进程互相访问其实也用得了异步和同步，比如UI界面和数据的连携，或者UI组件和主窗口的响应。无论是哪一种，同步异步只有对于不同场合的应用好坏，并无必须性。</p><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>数学上的互斥既是<strong>不可能同时发生的事件</strong>。</p><p>而编程或者说计算机中的互斥，针对的对象则是进程。在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。</p><p>最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</p><p>所以我们经常讲的都是进程互斥。</p><p>对立的概念则是<strong>同时性</strong>，某些资源可以被同时调用。比如对某文件的<strong>读操作</strong>。我们同样可以把这个概念套用在编程中，比如典型的互斥锁。这些我将会在后面的锁那一章讲明。</p><hr><p>这篇文章写完的时候已经4月5日了，我花了很多的时间去学习法语，便把我的信息专业搁置了。法语的一切一切都让我痛苦，并不塔诺西。还是编程好玩。总之，征途继续，明天就是锁那一章了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨日的笔试中被问到读写锁的定义和用途，突然发现读写和锁这两个词分开来我很熟悉，但合在一块儿我就一脸懵逼了。所以今天我特意花了一大部分时间来研究这些机制和各种锁。尽管网上大家说的都不太一样，但我还是梳理了一下我所理解的同步，互斥，阻塞和锁。但是锁的内容有些繁杂，我们先分清同步和阻塞这两个概念。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>记录本博客的第一次迁移</title>
    <link href="http://timlyeee.github.io/2021/03/10/Hexo-on-a-new-computer/"/>
    <id>http://timlyeee.github.io/2021/03/10/Hexo-on-a-new-computer/</id>
    <published>2021-03-10T15:57:31.000Z</published>
    <updated>2023-01-05T12:56:11.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迁移的目的"><a href="#迁移的目的" class="headerlink" title="迁移的目的"></a>迁移的目的</h2><p>我现在大多数时间都是在用windows系统的这台电脑，所以原本的码字用的mac逐渐被我舍弃。之前的博客也需要被迁移。虽然这么说，但是我其实没有那么多文章在这个博客上。</p><p>这是我第一次迁移，算是一个踩坑的过程和指令的熟练过程</p><span id="more"></span><h2 id="基本工作"><a href="#基本工作" class="headerlink" title="基本工作"></a>基本工作</h2><p>这个系统本身就有NodeJS存在，所以我不需要从头开始装Node，但是原本npm都是在国外下载的，所以回国之后需要安装一下淘宝镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>接下来就是直接把原本的所有内容拷贝到这台电脑上，这取决于用了多少包和文章。不过说实话，用RSS下载的时间和用U盘拷贝的时间我更偏向后者。有这么快的传输速度为什么不用？</p><p>拷贝之后需要更新一下包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install </span><br><span class="line">//或者fix用来校对一下版本</span><br><span class="line">npm audit fix</span><br></pre></td></tr></table></figure><p>然后以防万一，安装一下全局hexo-cli</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>做到这一步我们可以开始测试hexo的各项功能。</p><h2 id="本地服务器"><a href="#本地服务器" class="headerlink" title="本地服务器"></a>本地服务器</h2><p>首先是Hexo server，这一步对我来说是OK的，本地服务器能够完美运行。</p><p>但是Hexo new并不能正常运行，</p><blockquote><p>报错：ERROR Plugin load failed: hexo-renderer-sass</p></blockquote><p>这是用来将sass语言转换为css语言的项目依赖。实际上我在第一次实习的时候有接触过。但是用的不多。查找之后， 发现只需要重装就行。</p><p>其实在这一步的时候我是没有安装淘宝镜像的，所以报了另外一个错误。</p><blockquote><p>“Unexpected end of JSON input while parsing near···”</p></blockquote><p>这是因为我在之前install各项内容时，并没有找到所有的源地址，从而导致了写入Json文件时错误。因为仔细观察这个错误会发现是package-lock.json文件中错误。</p><p>所以我重新清理了缓存并且卸载重装了node-sass包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;npm WARN using --force I sure hope you know what you are doing.</span></span><br><span class="line">cnpm install node-sass</span><br></pre></td></tr></table></figure><p>至此，就可以使用hexo new命令了。</p><h2 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h2><p>和Mac上一样，如果需要只用hexo deploy命令就将新的内容部署到博客上，只需要将本机的ssh绑定到github上就行。至此，所有步骤都顺利完成了。也就有了这篇博文。</p><p>关于ssh的获取和赋值方法，网上搜搜就知道了。</p><hr><p>我已经好久没有登录我的博客了，以至于我都快忘了自己当初立下的誓言。总感觉我的冲劲正在一点点的被消磨耗尽。但今天笔试乐狗科技让我意识到，要是连工都没得打的话，那岂不是连冲出去的机会都没有了？冲劲又往哪里去放呢？</p><p>这样想着，我还是决定把东西记录下来，至少这次春招会让我学到很多东西。我没有参加秋招，等于我失去了一次机会，如果没有成功通过这些笔试和面试，那么，我就只能去做社会招聘？或者继续蹭下一届的校园招聘，那我就离自己的游戏开发的梦想越来越远了。</p><p>也是这样想着，又苦于自己的法语还没考过，如果4月9日的考试还是没法考到B2的话，自己的人生又要往后拖了。我今年24，离30岁并不远了。这些压力似乎在逼着我热爱上编程这个职业，让我爱上努力这件事。明明我是很懒的一个人。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;迁移的目的&quot;&gt;&lt;a href=&quot;#迁移的目的&quot; class=&quot;headerlink&quot; title=&quot;迁移的目的&quot;&gt;&lt;/a&gt;迁移的目的&lt;/h2&gt;&lt;p&gt;我现在大多数时间都是在用windows系统的这台电脑，所以原本的码字用的mac逐渐被我舍弃。之前的博客也需要被迁移。虽然这么说，但是我其实没有那么多文章在这个博客上。&lt;/p&gt;
&lt;p&gt;这是我第一次迁移，算是一个踩坑的过程和指令的熟练过程&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>c++Reference</title>
    <link href="http://timlyeee.github.io/2020/09/28/c-Reference/"/>
    <id>http://timlyeee.github.io/2020/09/28/c-Reference/</id>
    <published>2020-09-28T12:29:21.000Z</published>
    <updated>2023-01-05T12:56:11.062Z</updated>
    
    <content type="html"><![CDATA[<p>在我上大二那会儿，我才刚刚开始接触C++和C语言。我们的老师是法国老师A，一口法语说的贼溜，所以没有任何同学能听懂（笑😊）。所以老A讲C++指针和引用那一块儿的时候，我完全乱做一团。（嗯，关于老A的故事实在为0，所以要是哪一天我的记忆能够导出到电脑，说不定我能在blog里讲一讲。）</p><p>总之，哪怕是有中文助教，我还是上网查了半天记了半天笔记。</p><p>然后现在全忘了😭</p><p>这两天在研究院儿里做项目，用的是c#，c#也是Unity的编程语言，我才猛然发现，由于之前写了太多JS代码，对于内存管理这一块儿实在投入太少，趁着今天查了一些东西，感觉把它们都记下来。说不定以后面试刷题能用到？</p><span id="more"></span><p>先从C++开始：<br>C++和C#的最大不同就是内存的清理。同样是面向对象语言，C#的内存管理更加简单易懂，如果不需要知道原理，用起来并不费事。但是C++不同，几乎所有的内存管理都是由程序员自己决定的。这也是为什么构造函数和解构函数会存在了。</p><p>先扒一段菜鸟教程上的代码😛</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  var1;</span><br><span class="line"><span class="type">char</span> var2[<span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;var1 变量的地址： &quot;</span>;</span><br><span class="line">cout &lt;&lt; &amp;var1 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;var2 变量的地址： &quot;</span>;</span><br><span class="line">cout &lt;&lt; &amp;var2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 变量的地址： 0xbfebd5c0</span><br><span class="line">var2 变量的地址： 0xbfebd5b6</span><br></pre></td></tr></table></figure><p>所以&amp;这个符号直接使用的时候表示的就是地址啦。那么如果我想要在被调用的函数中直接使用这个变量，而不是在函数中复制一个新的变量，应该怎么引用它呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明简单的变量</span></span><br><span class="line">    <span class="type">int</span>    i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 声明引用变量</span></span><br><span class="line">    <span class="type">int</span>&amp;    r = i;</span><br><span class="line">    <span class="type">double</span>&amp; s = d;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    r ++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    d = <span class="number">11.7</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span>     j = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>&amp;    l = j;</span><br><span class="line">    <span class="built_in">Swap</span>( r , l );</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of j : &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Value of i : 5</span><br><span class="line">Value of i reference : 5</span><br><span class="line">Value of i : 6</span><br><span class="line">Value of i reference : 6</span><br><span class="line">Value of d : 11.7</span><br><span class="line">Value of d reference : 11.7</span><br><span class="line">Value of i : 1</span><br><span class="line">Value of j : 6</span><br></pre></td></tr></table></figure><p>所以简单来讲，就是声明变量时和传入参数时带上&amp;就行。那么引用是否可以满足我们日常的需求了呢？对于C++而言，不够。</p><blockquote><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul></blockquote><p>在我学C++那会儿，指针从来都是在IEnumerater里面做指向作用，由于需要操作的对象需要时时刻刻变化，不可能每遇到一个需要操作的对象就创建一个引用，那样的话创建引用的内存都要赶上创建对象的内存了（笑）。</p><p>所以顾名思义，指针就是用来指向操作对象的。通常被用在各种流程操作中。</p><p>那么指针怎么创建和传入参数？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  var = <span class="number">20</span>;   <span class="comment">// 实际变量的声明</span></span><br><span class="line"><span class="type">int</span>  *ip;        <span class="comment">// 指针变量的声明</span></span><br><span class="line"> </span><br><span class="line">ip = &amp;var;       <span class="comment">// 在指针变量中存储 var 的地址</span></span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of var variable: &quot;</span>;</span><br><span class="line">cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出在指针变量中存储的地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Address stored in ip variable: &quot;</span>;</span><br><span class="line">cout &lt;&lt; ip &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 访问指针中地址的值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of *ip variable: &quot;</span>;</span><br><span class="line">cout &lt;&lt; *ip &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value of var variable: 20</span><br><span class="line">Address stored in ip variable: 0xbfc601ac</span><br><span class="line">Value of *ip variable: 20</span><br></pre></td></tr></table></figure><p>不难发现，不仅变量的声明方法与引用不同，调用里面value的写法也不一样。</p><p>这也是我当年搞不懂的地方之一。设想一下我如果把代码写成下面这些样子，哪些能运行，哪些有意义？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 声明简单的变量</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">20</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="type">int</span> *a;</span><br><span class="line">    a=&amp;i;</span><br><span class="line"><span class="type">int</span> *b=i;</span><br><span class="line"><span class="type">int</span> *c=&amp;i;</span><br><span class="line">   <span class="type">int</span> *d= <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of *a: &quot;</span> &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of *b: &quot;</span> &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of *c: &quot;</span> &lt;&lt; *c &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of *d: &quot;</span> &lt;&lt; *d &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   *d=i;</span><br><span class="line">   </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of *d: &quot;</span> &lt;&lt; *d &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value of *a: 20</span><br><span class="line">Value of *b: Invalid!!!</span><br><span class="line">Value of *c: 20</span><br><span class="line">Value of *d: 5</span><br><span class="line">Value of *d: 20</span><br></pre></td></tr></table></figure><p>在上述4中声明中，第二种是无法编译的，但却是最容易犯的错误。原因很简单，我们调用b的值时候，cout&lt;&lt;*b是很自然的事情，但如果想要让声明的变量b的值等同于i，这种写法就不行了。</p><p>但是！如果我们在声明完变量d之后，让d地址中储存的值和i的值相等，就可以用等于号了。</p><p>是不是很神奇？所以这个写法被我很自然地列在编程反人类行为Top10中🤮</p><p>至于作为传参的指针以及跟函数的关系，我们就单开一章讲了（笑）。</p><p>现在看看C#里面的引用。</p><p>如果不开启Unsafe模式的化，C#的引用简直简单到爆！只需要在变量前面加上ref就行了！开启Unsafe之后的代码倒和C++没什么区别了。</p><p>继续借，这次是Microsoft Doc的代码（我们程序员难道没有自己的代码嘛？？😂）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> refArgument</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    refArgument = refArgument + <span class="number">44</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> number = <span class="number">1</span>;</span><br><span class="line">Method(<span class="keyword">ref</span> number);</span><br><span class="line">Console.WriteLine(number);</span><br><span class="line"><span class="comment">// Output: 45</span></span><br></pre></td></tr></table></figure><p>没有符号，因为不安全。。。</p><p>这一点在我初识C#的时候简直不敢相信，这是因为C#默认的内存管理已经非常完善了，尤其是.Net开发组对自己的程序开发特别的自信。不然也不至于把调用指针的代码块标注成Unsafe了（笑）。</p><p>行吧，再次把C++的指针搞懂了就行，后续还是会在C#上开发了。</p><hr><p>再说点日常。我上的大学是中法合作办学，来教编程的都是法国人，当时的课堂作业就是用C++写List类，从一开始的简单数组到后面的模板类List和Iterator全都写一遍。不得不说，这样写一遍下来基本上C++的各方各面都懂了。上完之后我还是很佩服的。</p><p>结果到了法国留学的时候，Java编程课又写了一遍。。。于是我硬着头皮问老师为啥这么爱写List。老师愣了一下，说：</p><p>“懒的编教材。”</p><p>好吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我上大二那会儿，我才刚刚开始接触C++和C语言。我们的老师是法国老师A，一口法语说的贼溜，所以没有任何同学能听懂（笑😊）。所以老A讲C++指针和引用那一块儿的时候，我完全乱做一团。（嗯，关于老A的故事实在为0，所以要是哪一天我的记忆能够导出到电脑，说不定我能在blog里讲一讲。）&lt;/p&gt;
&lt;p&gt;总之，哪怕是有中文助教，我还是上网查了半天记了半天笔记。&lt;/p&gt;
&lt;p&gt;然后现在全忘了😭&lt;/p&gt;
&lt;p&gt;这两天在研究院儿里做项目，用的是c#，c#也是Unity的编程语言，我才猛然发现，由于之前写了太多JS代码，对于内存管理这一块儿实在投入太少，趁着今天查了一些东西，感觉把它们都记下来。说不定以后面试刷题能用到？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>梦想要先从有背景板开始</title>
    <link href="http://timlyeee.github.io/2019/10/16/Dream-start/"/>
    <id>http://timlyeee.github.io/2019/10/16/Dream-start/</id>
    <published>2019-10-16T14:23:50.000Z</published>
    <updated>2023-01-05T12:56:11.061Z</updated>
    
    <content type="html"><![CDATA[<p>最近迷上了像素游戏，说起来我一直的梦想就是从事游戏，虚拟现实之类的工作。所以近期想要开始从事这一方面的东西。算是个学习过程吧。</p><p>Hexo的文档也一并开始写，之前跳票太久，我是想把自己学过的东西都写下来做个存档，这样以后忘记了就可以快速查阅，这样还可以修改一下Hexo的项目做个索引。</p><p>这个Blog大概率不会记录比较基础的或者代码用法上面的内容，大部分代码内容我应该会直接开Repo实操。主要记录的是C#，C++中与游戏开发有关的的难点，疑点，如果不围绕着游戏开发做一些文章，我这个博客就没啥子意思了。</p><p>我的两个比较长远的目标，一个是成为一名独立游戏开发者，或者是成立一个游戏开发组去实现脑子里各种稀奇古怪的想法。另一个就是训练一个模型帮我画像素画，不然以我的美术功底，我想要画出可以做游戏的像素素材，比训练模型还要久。</p><p>还是要提一句 ：<strong>本博客仅供参考娱乐，不做商用，欢迎交流</strong> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近迷上了像素游戏，说起来我一直的梦想就是从事游戏，虚拟现实之类的工作。所以近期想要开始从事这一方面的东西。算是个学习过程吧。&lt;/p&gt;
&lt;p&gt;Hexo的文档也一并开始写，之前跳票太久，我是想把自己学过的东西都写下来做个存档，这样以后忘记了就可以快速查阅，这样还可以修改一下H</summary>
      
    
    
    
    
  </entry>
  
</feed>
